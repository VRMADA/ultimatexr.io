---
title: "Getting User Input"
---

# Getting User Input

## `UxrControllerInput`

The active `UxrControllerInput` component can be accessed using `UxrAvatar.LocalAvatarInput`. The `LocalAvatarInput` is a static property, which means it can be used globally from anywhere in the code. It will return the currently active controller input component, or a dummy component if no controller is currently active.
A dummy controller input removes the need for null checks and will not generate any input events.

## Controller Type

`UxrControllerInput` exposes the `SetupType` property, which can have the following values:
- `UxrControllerSetupType.Single`: Single controller setup, such as a gamepad, remote or a gun.
- `UxrControllerSetupType.Dual`: Dual controller setup (left+right controllers).

**Image**: A dual controller setup on the left (Quest 3 controllers) and single controllers on the right (Oculus Go and Gamepad).
![](/docs/programming-guide/media/ControllerTypes.png)

## Controller Capabilities

`UxrControllerInput` also exposes the `GetControllerCapabilities()` method, which will return `UxrControllerInputCapabilities` flags:
- `HapticImpulses`: The controller supports raw haptic impulses.
- `HapticClips`: The controller supports haptic impulses defined by an audio clip.
- `TrackedHandPose`: The controller supports finger tracking, through capacitive sensors or similar. For example the Valve Index have this capability.

{{% callout info %}}
Haptic impulses in VR controllers refer to tactile feedback generated by embedded motors to simulate touch or force sensations for enhanced immersion.
{{% /callout %}}

## Controller Handedness

Handedness refers to the distinction between left-handed and right-handed controllers. In `Dual` controller setups each controller is grabbed using a different hand. In `Single` controller setups, handedness might be supported or not.
In devices with a single controller, such as the old Oculus Go, for example, the controller could be configured for the left hand or the right hand. In a gamepad, however, handedness does not apply.

Whether handedness is supported or not is indicated by the `IsHandednessSupported` property.

When handedness is supported, the following properties dictate the behavior:
- `Handedness`: Specifies the primary controller side In `Single` setups, it indicates which hand wields the controller. For `Dual` setups, it designates the hand wielding the primary controller. Input can be queried for left and right sides, as well as for primary and secondary.
- `Primary`/`Secondary`: Will translate to left or right depending on the `Handedness` assigned.

{{% callout tip %}}
Changing the Handedness property allows logic to be implemented that supports both left-handed and right-handed users.
{{% /callout %}}

When handedness is not supported, all calls will target the single controller.

## Ignoring Input

Occasionally, it can be useful to deactivate input from a controller.

`UxrControllerInput` provides two static methods for ignoring **any** input coming from a specific side.

```c#
static bool GetIgnoreControllerInput(UxrHandSide handSide)
static void SetIgnoreControllerInput(UxrHandSide handSide, bool ignore)
```

`GetIgnoreControllerInput()` checks whether ignoring is currently enabled on the specified side.
`SetIgnoreControllerInput()` enables or disables ignoring input coming from the specified side.

It is still possible, however, to get input from a controller that is being ignored. By default, all methods that query for user input will not return any data. These methods have an optional `getIgnoredInput` parameter that can be set to `true` to get input even if the controller is set to be ignored.

This functionality can be used to, for example, ignore input while a virtual controller is being manipulated to avoid teleporting:
![](/docs/programming-guide/media/ControllerMapping.gif)

## Elements in a Controller

Despite variations among controllers, they share common elements. These include:
- **Buttons**, managed using `UxrInputButtons` flags.
- **Single-axis analog input**, such as trigger input, identified by the `UxrInput1D` type.
- **Two-axis analog input**, like an analog joystick, identified by the `UxrInput2D` type.

Buttons have discrete states, pressed or depressed, while analog inputs provide continuous input ranging from 0.0 to 1.0. `UxrInput1D` elements provide a single, analog input. `UxrAxis2D` provides an analog input with 2 components, such as the xy values of a joystick.

To identify controller elements, regardless of type, UltimateXR uses the `UxrControllerElements` enum supporting:
- `Joystick`: Primary joystick.
- `Joystick2`: Secondary joystick. Some controllers have 2 joysticks, such as the Windows Mixed Reality or the Valve Index.
- `DPad`: Directional pad. The D-pad typically consists of a cross-shaped arrangement of four directional buttons (up, down, left, and right). If not available, the primary joystick is usually mapped to the dpad.
- `Trigger`: Input button typically controlled with the index finger. The trigger is normally pressure-sensitive, allowing for varying degrees of input based on how firmly the user presses it.
- `Trigger2`: Secondary trigger. A gamepad, for instance, has 2 triggers.
- `Grip`: Input button typically controlled with the middle finger. Like the trigger, the grip is normally pressure-sensitive.
- `ThumbCapSense`: Capacitive sensor for the thumb.
- `IndexCapSense`: Capacitive sensor for the index finger.
- `MiddleCapSense`: Capacitive sensor for the middle finger.
- `RingCapSense`: Capacitive sensor for the ring finger.
- `LittleCapSense`: Capacitive sensor for the little finger.
- `Button1`: The button 1.
- `Button2`: The button 2.
- `Button3`: The button 3.
- `Button4`: The button 4.
- `Bumper`: The primary bumper, also called shoulder, button.
- `Bumper2`: The secondary bumper, also called shoulder, button. A gamepad, for instance, has 2 bumpers.
- `Back`: The back button.
- `Menu`: The menu button.

## Buttons

Buttons provide discrete input, either pressed or depressed.

UltimateXR supports the following buttons through the `UxrInputButtons` flags:

- `UxrInputButtons.Joystick`
- `UxrInputButtons.JoystickLeft`
- `UxrInputButtons.JoystickRight`
- `UxrInputButtons.JoystickUp`
- `UxrInputButtons.JoystickDown`
- `UxrInputButtons.Joystick2`
- `UxrInputButtons.Joystick2Left`
- `UxrInputButtons.Joystick2Right`
- `UxrInputButtons.Joystick2Up`
- `UxrInputButtons.Joystick2Down`
- `UxrInputButtons.DPadLeft`
- `UxrInputButtons.DPadRight`
- `UxrInputButtons.DPadUp`
- `UxrInputButtons.DPadDown`
- `UxrInputButtons.Trigger`
- `UxrInputButtons.Trigger2`
- `UxrInputButtons.Grip`
- `UxrInputButtons.ThumbCapSense`
- `UxrInputButtons.IndexCapSense`
- `UxrInputButtons.MiddleCapSense`
- `UxrInputButtons.RingCapSense`
- `UxrInputButtons.LittleCapSense`
- `UxrInputButtons.Button1`
- `UxrInputButtons.Button2`
- `UxrInputButtons.Button3`
- `UxrInputButtons.Button4`
- `UxrInputButtons.Bumper`
- `UxrInputButtons.Bumper2`
- `UxrInputButtons.Back`
- `UxrInputButtons.Menu`

Input components will provide input for their available buttons. There are some special cases, where DPad, for example, will be assigned the joystick data as digital values if no DPad is available. This is to improve support when controllers lack certain elements.

Some buttons are analog in nature but will generate digital values when used with `UxrInputButtons`. For example `Trigger` or `Grip`.

### Button Input Methods

The following groups of methods can be used to check for button events:

#### Press States

```c#
bool GetButtonsPress       (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsPressAny    (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsPressDown   (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsPressDownAny(UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsPressUp     (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsPressUpAny  (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
```

In the methods above, `handSide` specifies the hand to check, while `buttons` denotes the specific button or buttons, indicated by combining flags. The optional parameter `getIgnoredInput` controls whether to retrieve input events for [ignored controllers](#ignoring-input). By default, it's set to `false`; using `true` should be limited to cases where it's truly necessary.

{{% callout tip %}}
Passing the `Handedness` property as `handSide` will query the primary hand. By maintaining a handedness setting, we can implement logic to support both left-handed and right-handed users.
{{% /callout %}}

These methods determine whether a button or group of buttons is currently pressed (`Press`), pressed during the current frame (`PressDown`), or released during the current frame (`PressUp`).
Since `buttons` are represented by flags, it's possible to combine multiple buttons and check for them simultaneously.
When combining multiple buttons with flags, these methods will return `true` only if **all** buttons are in the requested state. Conversely, the `Any` variations will return `true` as long as at least one button is in the requested state.

**Example1:** This line will check whether the right hand trigger was released. Here the trigger will work as a digital button, either pressed or depressed:

```c#
bool isTriggerReleased = UxrAvatar.LocalAvatarInput.GetButtonPressUp(UxrHandSide.Right, UxrInputButtons.Trigger);
```

**Example2:** This line will check whether the Button1 and Button2 from the left side are being pressed at the same time:

```c#
bool areButtonsPressed = UxrAvatar.LocalAvatarInput.GetButtonPress(UxrHandSide.Left, UxrInputButtons.Button1 | UxrInputButtons.Button2);
```

**Example3:** This line will check if either Button1 or Button2 from the left side is being pressed:

```c#
bool isAnyPressed = UxrAvatar.LocalAvatarInput.GetButtonPressAny(UxrHandSide.Left, UxrInputButtons.Button1 | UxrInputButtons.Button2);
```

#### Touch States

```c#
bool GetButtonsTouch       (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsTouchAny    (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsTouchDown   (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsTouchDownAny(UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsTouchUp     (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsTouchUpAny  (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
```

These methods function similarly to their `Press` counterparts but are for Touch events instead of Press events. A Touch event registers with a light press of the button, while Press events require a full button press. Not all controllers and buttons support Touch events, as they require a capacitive sensor.

#### State flags

```c#
uint GetButtonPressFlags         (UxrHandSide handSide, bool getIgnoredInput)
uint GetButtonPressFlagsLastFrame(UxrHandSide handSide, bool getIgnoredInput)

uint GetButtonTouchFlags         (UxrHandSide handSide, bool getIgnoredInput)
uint GetButtonTouchFlagsLastFrame(UxrHandSide handSide, bool getIgnoredInput)

```

These methods return the state flags for button presses and touches. These flags will tell which buttons are currently being pressed or touched and which buttons were being pressed or touched the last frame.
Working with flags requires using bitwise logical operators.

`handSide` specifies the hand to check and the parameter `getIgnoredInput` controls whether to retrieve input events for ignored controllers. By default, it's set to `false`; using `true` should be limited to cases where it's truly necessary. Ignoring controller input will be covered [below](#ignoring-input).

Let's see some examples:

**Example1:** This line will check whether the left `Button1` is being pressed:

```c#
bool isButton1Pressed = (UxrAvatar.LocalAvatarInput.GetButtonPressFlags(UxrHandSide.Left) & UxrInputButtons.Button1) != 0;
```

**Example2:** This line will check whether the right `Button2` was pressed the last frame but not the current frame. This means that it was just released.

```c#
bool isButton2Released = (UxrAvatar.LocalAvatarInput.GetButtonPressFlags         (UxrHandSide.Right) & UxrInputButtons.Button2) == 0 &&
                         (UxrAvatar.LocalAvatarInput.GetButtonPressFlagsLastFrame(UxrHandSide.Right) & UxrInputButtons.Button2) != 0;
```

**Example3:** This line will check if any button from the left controller is being pressed:

```c#
bool isAnyLeftPressed = UxrAvatar.LocalAvatarInput.GetButtonPressFlags(UxrHandSide.Left) != 0;
```

**Example4:** This line will check if `Button1` and `Button2` are currently being pressed at the same time:

```c#
bool areBothPressed = (UxrAvatar.LocalAvatarInput.GetButtonPressFlags(UxrHandSide.Left) & (UxrInputButtons.Button1 | UxrInputButtons.Button2)) != 0;
```

{{% callout caution %}}
When using input functionality that relies on values from the current or previous frames, it's crucial to make sure that the queries are performed [after the input was updated](/docs/programming-guide/architecture-uxrmanager#stage-update-events). 
{{% /callout %}}

#### Event Querying

```c#
bool GetButtonsEvent   (UxrHandSide handSide, UxrInputButtons buttons, UxrButtonEventType buttonEventType, bool getIgnoredInput)
bool GetButtonsEventAny(UxrHandSide handSide, UxrInputButtons buttons, UxrButtonEventType buttonEventType, bool getIgnoredInput)
```

These methods provide another way to query. `handSide` specifies the hand to check, `buttons` specifies one or more button flags and the parameter `getIgnoredInput` controls whether to retrieve input events for ignored controllers. By default, it's set to `false`; using `true` should be limited to cases where it's truly necessary. Ignoring controller input will be covered [below](#ignoring-input).
Using the `buttonEventType` parameter, it is possible to check for different input events:
- `Touching`: whether the button is being touched.
- `TouchDown`: whether a touch started the present frame.
- `TouchUp`: whether the touch was released.
- `Pressing`: whether the button is being pressed.
- `PressDown`: whether a press started the present frame.
- `PressUp`: whether the press was released.

When combining multiple buttons with flags, `GetButtonsEvent()` will return `true` only if **all** buttons meet the event conditions. Conversely, `GetButtonsEventAny()` will return `true` as long as at least one button meets the criteria.

**Example1:** This line will check whether the right `Button1` is being pressed:

```c#
bool isButton1Pressed = UxrAvatar.LocalAvatarInput.GetButtonsEvent(UxrHandSide.Right, UxrInputButtons.Button1, UxrButtonEventType.Pressing);
```

**Example2:** This line will check whether the Button1 and Button2 from the left side are being pressed at the same time:

```c#
bool areButtonsPressed = UxrAvatar.LocalAvatarInput.GetButtonsEvent(UxrHandSide.Left, UxrInputButtons.Button1 | UxrInputButtons.Button2, UxrButtonEventType.Pressing);
```

**Example3:** This line will check if either Button1 or Button2 from the left side was released:

```c#
bool isAnyReleased = UxrAvatar.LocalAvatarInput.GetButtonsEventAny(UxrHandSide.Left, UxrInputButtons.Button1 | UxrInputButtons.Button2, UxrButtonEventType.PressUp);
```

### Button Events

`GlobalButtonStateChanged`

## `UxrInput1D`

## `UxrInput2D`

## DebugInputPanel